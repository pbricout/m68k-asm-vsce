/**
 * Test utilities for M68K Assembly Language Extension
 * 
 * This module provides utilities for testing various components of the extension,
 * including file parsing, symbol detection, and provider functionality.
 */

import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import * as vscode from 'vscode';
import { M68kFileParser, ParseContext, SymbolInfo } from './fileParser';
import { M68kAsmConfig } from './config';

/**
 * Test configuration for isolated testing
 */
export interface TestConfig {
    tempDir?: string;
    includePaths?: string[];
    config?: M68kAsmConfig;
}

/**
 * Creates a temporary directory for test files
 */
export function createTempDir(prefix: string = 'm68k-test-'): string {
    const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), prefix));
    return tempDir;
}

/**
 * Cleans up a temporary directory and all its contents
 */
export function cleanupTempDir(tempDir: string): void {
    if (fs.existsSync(tempDir)) {
        fs.rmSync(tempDir, { recursive: true, force: true });
    }
}

/**
 * Creates a test file with the given content
 */
export function createTestFile(filePath: string, content: string): void {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(filePath, content, 'utf8');
}

/**
 * Creates a test M68K assembly file with common patterns
 */
export function createTestAssemblyFile(filePath: string, options: {
    labels?: string[];
    macros?: Array<{ name: string; params: string[] }>;
    includes?: string[];
    constants?: Array<{ name: string; value: string }>;
    instructions?: string[];
}): void {
    const lines: string[] = [];
    
    // Add header comment
    lines.push('; Test M68K Assembly File');
    lines.push('; Generated by testUtils.ts');
    lines.push('');
    
    // Add includes
    if (options.includes) {
        options.includes.forEach(include => {
            lines.push(`\tinclude\t"${include}"`);
        });
        lines.push('');
    }
    
    // Add constants
    if (options.constants) {
        options.constants.forEach(constant => {
            lines.push(`${constant.name}\tequ\t${constant.value}`);
        });
        lines.push('');
    }
    
    // Add macros
    if (options.macros) {
        options.macros.forEach(macro => {
            const params = macro.params.length > 0 ? `(${macro.params.join(',')})` : '';
            lines.push(`${macro.name}\tmacro${params}`);
            lines.push('\t; Macro body here');
            lines.push('\tendm');
            lines.push('');
        });
    }
    
    // Add labels and instructions
    if (options.labels) {
        options.labels.forEach((label, index) => {
            lines.push(`${label}:`);
            if (options.instructions && options.instructions[index]) {
                lines.push(`\t${options.instructions[index]}`);
            } else {
                lines.push('\tnop');
            }
            lines.push('');
        });
    }
    
    // Add default content if nothing specified
    if (!options.labels && !options.macros && !options.constants) {
        lines.push('start:');
        lines.push('\tmove.l\t#$1000,d0');
        lines.push('\trts');
    }
    
    createTestFile(filePath, lines.join('\n'));
}

/**
 * Creates a test include file
 */
export function createTestIncludeFile(filePath: string, constants: Array<{ name: string; value: string }> = []): void {
    const lines: string[] = [];
    lines.push('; Test include file');
    lines.push('');
    
    constants.forEach(constant => {
        lines.push(`${constant.name}\tequ\t${constant.value}`);
    });
    
    if (constants.length === 0) {
        lines.push('DEFAULT_VALUE\tequ\t$FF');
    }
    
    createTestFile(filePath, lines.join('\n'));
}

/**
 * Creates a test parse context
 */
export function createTestParseContext(options: {
    baseDir?: string;
    projectRoot?: string;
    config?: M68kAsmConfig;
    fallbackPath?: string;
}): ParseContext {
    // Create a mock document and lines array since ParseContext requires them
    const mockDocument = {
        lineCount: 1,
        lineAt: () => ({ text: '' }),
        getText: () => '',
        uri: { fsPath: options.baseDir || process.cwd() }
    } as any;
    
    return {
        document: mockDocument,
        lines: [''],
        filePath: options.baseDir || process.cwd(),
        baseDir: options.baseDir || process.cwd(),
        projectRoot: options.projectRoot || process.cwd(),
        fallbackPath: options.fallbackPath || './includes'
    };
}

/**
 * Test helper for parsing a file and extracting symbols
 */
export async function parseTestFile(filePath: string, context?: ParseContext): Promise<SymbolInfo[]> {
    const parseContext = context || createTestParseContext({ baseDir: path.dirname(filePath) });
    // Set the file path in the context to match the file we're parsing
    parseContext.filePath = filePath;
    parseContext.lines = M68kFileParser.readFileLines(filePath);
    return M68kFileParser.getAllSymbols(parseContext);
}

/**
 * Test helper for finding symbol definitions
 */
export async function findTestSymbolDefinition(
    filePath: string, 
    symbolName: string, 
    context?: ParseContext
): Promise<SymbolInfo | null> {
    const parseContext = context || createTestParseContext({ baseDir: path.dirname(filePath) });
    return M68kFileParser.findSymbolDefinition(filePath, symbolName, parseContext) || null;
}

/**
 * Test helper for finding symbol references
 */
export async function findTestSymbolReferences(
    filePath: string, 
    symbolName: string, 
    includeDeclaration: boolean = true,
    context?: ParseContext
): Promise<vscode.Location[]> {
    const parseContext = context || createTestParseContext({ baseDir: path.dirname(filePath) });
    return M68kFileParser.findSymbolReferences(symbolName, parseContext, includeDeclaration);
}

/**
 * Validates that a symbol has expected properties
 */
export function validateSymbol(symbol: SymbolInfo, expected: {
    name?: string;
    type?: 'label' | 'constant' | 'macro' | 'variable';
    filePath?: string;
    line?: number;
    character?: number;
}): boolean {
    if (expected.name && symbol.name !== expected.name) {
        return false;
    }
    if (expected.type && symbol.type !== expected.type) {
        return false;
    }
    if (expected.filePath && symbol.filePath !== expected.filePath) {
        return false;
    }
    if (expected.line !== undefined && symbol.line !== expected.line) {
        return false;
    }
    if (expected.character !== undefined && symbol.character !== expected.character) {
        return false;
    }
    return true;
}

/**
 * Asserts that an array contains a symbol with expected properties
 */
export function assertSymbolExists(symbols: SymbolInfo[], expected: {
    name?: string;
    type?: 'label' | 'constant' | 'macro' | 'variable';
    filePath?: string;
    line?: number;
    character?: number;
}): boolean {
    return symbols.some(symbol => validateSymbol(symbol, expected));
}

/**
 * Gets cache statistics for testing performance
 */
export function getCacheStats(): {
    fileCache: number;
    symbolCache: number;
} {
    return M68kFileParser.getCacheStats();
}

/**
 * Sample test data generator
 */
export class TestDataGenerator {
    /**
     * Generates a complete test project structure
     */
    static generateTestProject(baseDir: string): {
        mainFile: string;
        includeFiles: string[];
        configFile: string;
    } {
        const mainFile = path.join(baseDir, 'main.s');
        const includeDir = path.join(baseDir, 'include');
        const includeFiles = [
            path.join(includeDir, 'constants.i'),
            path.join(includeDir, 'macros.i')
        ];
        const configFile = path.join(baseDir, 'm68kasmconfig.json');
        
        // Create main assembly file
        createTestAssemblyFile(mainFile, {
            includes: ['include/constants.i', 'include/macros.i'],
            labels: ['main', 'loop', 'exit'],
            instructions: [
                'move.l #BUFFER_SIZE,d0',
                'dbra d0,loop',
                'rts'
            ]
        });
        
        // Create include files
        createTestIncludeFile(includeFiles[0], [
            { name: 'BUFFER_SIZE', value: '$1000' },
            { name: 'MAX_COUNT', value: '255' }
        ]);
        
        createTestAssemblyFile(includeFiles[1], {
            macros: [
                { name: 'PUSH_REGS', params: [] },
                { name: 'POP_REGS', params: [] },
                { name: 'DELAY', params: ['cycles'] }
            ]
        });
        
        // Create config file
        const config = {
            includeFallbackPath: "./include",
            enableIntelliSense: true,
            enableHover: true,
            cacheTimeout: 30,
            logLevel: "debug"
        };
        
        createTestFile(configFile, JSON.stringify(config, null, 2));
        
        return {
            mainFile,
            includeFiles,
            configFile
        };
    }
}

/**
 * Performance testing utilities
 */
export class PerformanceTester {
    private startTime: number = 0;
    private measurements: Map<string, number[]> = new Map();
    
    /**
     * Starts timing a operation
     */
    startTiming(): void {
        this.startTime = performance.now();
    }
    
    /**
     * Ends timing and records the measurement
     */
    endTiming(operationName: string): number {
        const duration = performance.now() - this.startTime;
        
        if (!this.measurements.has(operationName)) {
            this.measurements.set(operationName, []);
        }
        
        this.measurements.get(operationName)!.push(duration);
        return duration;
    }
    
    /**
     * Gets performance statistics for an operation
     */
    getStats(operationName: string): {
        count: number;
        average: number;
        min: number;
        max: number;
        total: number;
    } | null {
        const measurements = this.measurements.get(operationName);
        if (!measurements || measurements.length === 0) {
            return null;
        }
        
        const total = measurements.reduce((sum, val) => sum + val, 0);
        const average = total / measurements.length;
        const min = Math.min(...measurements);
        const max = Math.max(...measurements);
        
        return {
            count: measurements.length,
            average,
            min,
            max,
            total
        };
    }
    
    /**
     * Clears all measurements
     */
    clear(): void {
        this.measurements.clear();
    }
}
