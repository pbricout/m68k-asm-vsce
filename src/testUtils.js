"use strict";
/**
 * Test utilities for M68K Assembly Language Extension
 *
 * This module provides utilities for testing various components of the extension,
 * including file parsing, symbol detection, and provider functionality.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.PerformanceTester = exports.TestDataGenerator = exports.getCacheStats = exports.assertSymbolExists = exports.validateSymbol = exports.findTestSymbolReferences = exports.findTestSymbolDefinition = exports.parseTestFile = exports.createTestParseContext = exports.createTestIncludeFile = exports.createTestAssemblyFile = exports.createTestFile = exports.cleanupTempDir = exports.createTempDir = void 0;
var path = require("path");
var fs = require("fs");
var os = require("os");
var fileParser_1 = require("./fileParser");
/**
 * Creates a temporary directory for test files
 */
function createTempDir(prefix) {
    if (prefix === void 0) { prefix = 'm68k-test-'; }
    var tempDir = fs.mkdtempSync(path.join(os.tmpdir(), prefix));
    return tempDir;
}
exports.createTempDir = createTempDir;
/**
 * Cleans up a temporary directory and all its contents
 */
function cleanupTempDir(tempDir) {
    if (fs.existsSync(tempDir)) {
        fs.rmSync(tempDir, { recursive: true, force: true });
    }
}
exports.cleanupTempDir = cleanupTempDir;
/**
 * Creates a test file with the given content
 */
function createTestFile(filePath, content) {
    var dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(filePath, content, 'utf8');
}
exports.createTestFile = createTestFile;
/**
 * Creates a test M68K assembly file with common patterns
 */
function createTestAssemblyFile(filePath, options) {
    var lines = [];
    // Add header comment
    lines.push('; Test M68K Assembly File');
    lines.push('; Generated by testUtils.ts');
    lines.push('');
    // Add includes
    if (options.includes) {
        options.includes.forEach(function (include) {
            lines.push("\tinclude\t\"".concat(include, "\""));
        });
        lines.push('');
    }
    // Add constants
    if (options.constants) {
        options.constants.forEach(function (constant) {
            lines.push("".concat(constant.name, "\tequ\t").concat(constant.value));
        });
        lines.push('');
    }
    // Add macros
    if (options.macros) {
        options.macros.forEach(function (macro) {
            var params = macro.params.length > 0 ? "(".concat(macro.params.join(','), ")") : '';
            lines.push("".concat(macro.name, "\tmacro").concat(params));
            lines.push('\t; Macro body here');
            lines.push('\tendm');
            lines.push('');
        });
    }
    // Add labels and instructions
    if (options.labels) {
        options.labels.forEach(function (label, index) {
            lines.push("".concat(label, ":"));
            if (options.instructions && options.instructions[index]) {
                lines.push("\t".concat(options.instructions[index]));
            }
            else {
                lines.push('\tnop');
            }
            lines.push('');
        });
    }
    // Add default content if nothing specified
    if (!options.labels && !options.macros && !options.constants) {
        lines.push('start:');
        lines.push('\tmove.l\t#$1000,d0');
        lines.push('\trts');
    }
    createTestFile(filePath, lines.join('\n'));
}
exports.createTestAssemblyFile = createTestAssemblyFile;
/**
 * Creates a test include file
 */
function createTestIncludeFile(filePath, constants) {
    if (constants === void 0) { constants = []; }
    var lines = [];
    lines.push('; Test include file');
    lines.push('');
    constants.forEach(function (constant) {
        lines.push("".concat(constant.name, "\tequ\t").concat(constant.value));
    });
    if (constants.length === 0) {
        lines.push('DEFAULT_VALUE\tequ\t$FF');
    }
    createTestFile(filePath, lines.join('\n'));
}
exports.createTestIncludeFile = createTestIncludeFile;
/**
 * Creates a test parse context
 */
function createTestParseContext(options) {
    // Create a mock document and lines array since ParseContext requires them
    var mockDocument = {
        lineCount: 1,
        lineAt: function () { return ({ text: '' }); },
        getText: function () { return ''; },
        uri: { fsPath: options.baseDir || process.cwd() }
    };
    return {
        document: mockDocument,
        lines: [''],
        filePath: options.baseDir || process.cwd(),
        baseDir: options.baseDir || process.cwd(),
        projectRoot: options.projectRoot || process.cwd(),
        fallbackPath: options.fallbackPath || './includes'
    };
}
exports.createTestParseContext = createTestParseContext;
/**
 * Test helper for parsing a file and extracting symbols
 */
function parseTestFile(filePath, context) {
    return __awaiter(this, void 0, void 0, function () {
        var parseContext;
        return __generator(this, function (_a) {
            parseContext = context || createTestParseContext({ baseDir: path.dirname(filePath) });
            // Set the file path in the context to match the file we're parsing
            parseContext.filePath = filePath;
            parseContext.lines = fileParser_1.M68kFileParser.readFileLines(filePath);
            return [2 /*return*/, fileParser_1.M68kFileParser.getAllSymbols(parseContext)];
        });
    });
}
exports.parseTestFile = parseTestFile;
/**
 * Test helper for finding symbol definitions
 */
function findTestSymbolDefinition(filePath, symbolName, context) {
    return __awaiter(this, void 0, void 0, function () {
        var parseContext;
        return __generator(this, function (_a) {
            parseContext = context || createTestParseContext({ baseDir: path.dirname(filePath) });
            return [2 /*return*/, fileParser_1.M68kFileParser.findSymbolDefinition(filePath, symbolName, parseContext) || null];
        });
    });
}
exports.findTestSymbolDefinition = findTestSymbolDefinition;
/**
 * Test helper for finding symbol references
 */
function findTestSymbolReferences(filePath, symbolName, includeDeclaration, context) {
    if (includeDeclaration === void 0) { includeDeclaration = true; }
    return __awaiter(this, void 0, void 0, function () {
        var parseContext;
        return __generator(this, function (_a) {
            parseContext = context || createTestParseContext({ baseDir: path.dirname(filePath) });
            return [2 /*return*/, fileParser_1.M68kFileParser.findSymbolReferences(symbolName, parseContext, includeDeclaration)];
        });
    });
}
exports.findTestSymbolReferences = findTestSymbolReferences;
/**
 * Validates that a symbol has expected properties
 */
function validateSymbol(symbol, expected) {
    if (expected.name && symbol.name !== expected.name) {
        return false;
    }
    if (expected.type && symbol.type !== expected.type) {
        return false;
    }
    if (expected.filePath && symbol.filePath !== expected.filePath) {
        return false;
    }
    if (expected.line !== undefined && symbol.line !== expected.line) {
        return false;
    }
    if (expected.character !== undefined && symbol.character !== expected.character) {
        return false;
    }
    return true;
}
exports.validateSymbol = validateSymbol;
/**
 * Asserts that an array contains a symbol with expected properties
 */
function assertSymbolExists(symbols, expected) {
    return symbols.some(function (symbol) { return validateSymbol(symbol, expected); });
}
exports.assertSymbolExists = assertSymbolExists;
/**
 * Gets cache statistics for testing performance
 */
function getCacheStats() {
    return fileParser_1.M68kFileParser.getCacheStats();
}
exports.getCacheStats = getCacheStats;
/**
 * Sample test data generator
 */
var TestDataGenerator = /** @class */ (function () {
    function TestDataGenerator() {
    }
    /**
     * Generates a complete test project structure
     */
    TestDataGenerator.generateTestProject = function (baseDir) {
        var mainFile = path.join(baseDir, 'main.s');
        var includeDir = path.join(baseDir, 'include');
        var includeFiles = [
            path.join(includeDir, 'constants.i'),
            path.join(includeDir, 'macros.i')
        ];
        var configFile = path.join(baseDir, 'm68kasmconfig.json');
        // Create main assembly file
        createTestAssemblyFile(mainFile, {
            includes: ['include/constants.i', 'include/macros.i'],
            labels: ['main', 'loop', 'exit'],
            instructions: [
                'move.l #BUFFER_SIZE,d0',
                'dbra d0,loop',
                'rts'
            ]
        });
        // Create include files
        createTestIncludeFile(includeFiles[0], [
            { name: 'BUFFER_SIZE', value: '$1000' },
            { name: 'MAX_COUNT', value: '255' }
        ]);
        createTestAssemblyFile(includeFiles[1], {
            macros: [
                { name: 'PUSH_REGS', params: [] },
                { name: 'POP_REGS', params: [] },
                { name: 'DELAY', params: ['cycles'] }
            ]
        });
        // Create config file
        var config = {
            includeFallbackPath: "./include",
            enableIntelliSense: true,
            enableHover: true,
            cacheTimeout: 30,
            logLevel: "debug"
        };
        createTestFile(configFile, JSON.stringify(config, null, 2));
        return {
            mainFile: mainFile,
            includeFiles: includeFiles,
            configFile: configFile
        };
    };
    return TestDataGenerator;
}());
exports.TestDataGenerator = TestDataGenerator;
/**
 * Performance testing utilities
 */
var PerformanceTester = /** @class */ (function () {
    function PerformanceTester() {
        this.startTime = 0;
        this.measurements = new Map();
    }
    /**
     * Starts timing a operation
     */
    PerformanceTester.prototype.startTiming = function () {
        this.startTime = performance.now();
    };
    /**
     * Ends timing and records the measurement
     */
    PerformanceTester.prototype.endTiming = function (operationName) {
        var duration = performance.now() - this.startTime;
        if (!this.measurements.has(operationName)) {
            this.measurements.set(operationName, []);
        }
        this.measurements.get(operationName).push(duration);
        return duration;
    };
    /**
     * Gets performance statistics for an operation
     */
    PerformanceTester.prototype.getStats = function (operationName) {
        var measurements = this.measurements.get(operationName);
        if (!measurements || measurements.length === 0) {
            return null;
        }
        var total = measurements.reduce(function (sum, val) { return sum + val; }, 0);
        var average = total / measurements.length;
        var min = Math.min.apply(Math, measurements);
        var max = Math.max.apply(Math, measurements);
        return {
            count: measurements.length,
            average: average,
            min: min,
            max: max,
            total: total
        };
    };
    /**
     * Clears all measurements
     */
    PerformanceTester.prototype.clear = function () {
        this.measurements.clear();
    };
    return PerformanceTester;
}());
exports.PerformanceTester = PerformanceTester;
